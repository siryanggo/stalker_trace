它包含了最终的脚本，还详细解释了如何配置、如何运行以及如何看懂那些复杂的日志。

---

# Frida ARM64 Stalker Trace Pro

这是一个专为安卓逆向工程设计的 Frida Stalker 脚本。它在标准的指令追踪功能基础上，增加了**内存智能透视**、**SIMD (向量) 寄存器读取**以及**防崩溃机制**，是分析 JNI 算法还原、加密函数参数和复杂的汇编逻辑的利器。

## 🌟 核心功能

* **🛡️ 增强型防崩溃 (Anti-Crash)**: 内置指针合法性检测，只读取对齐且合法的内存地址，防止因读取非法地址导致的 Access Violation 崩溃。
* **🚀 SIMD/浮点寄存器支持**: 利用 `CModule` 技术突破 Frida JS 限制，直接读取 `q0` - `q15` (128位) 寄存器，完美还原加密算法（如 AES/ChaCha20）中的向量操作。
* **👀 智能内存透视**:
* 自动识别并读取寄存器指向的 **UTF-8 字符串**。
* 自动识别 **二级指针** (Pointer to Pointer)。
* 在 `LDR`/`STR` 内存操作时，自动显示该地址当前存储的值 (`[val=...]`)。


* **🎨 语义化高亮**:
* **黄色**: 函数调用 (`BL`, `BLR`)
* **红色**: 函数返回 (`RET`)
* **绿色**: 立即数 / 字符串
* **品红**: 寄存器变化


* **📉 循环折叠**: 自动检测并折叠紧密循环中的重复日志，防止日志文件瞬间爆炸。

---

## ⚙️ 使用配置

在运行脚本之前，请打开脚本文件，滚动到底部，根据你的目标修改以下两个变量：

```javascript
setImmediate(() => {
    // ⬇️⬇️ 请修改此处 ⬇️⬇️
    
    // 目标 so 文件的名称
    const TARGET_MODULE = "libnative-lib.so"; 
    
    // 目标函数的偏移地址 (从 IDA/Ghidra 中查看)
    // 提示：如果是 thumb 模式需 +1，但在 ARM64 (so) 中通常直接填偏移即可
    const TARGET_OFFSET = 0xa3c; 
    
    // ⬆️⬆️ 请修改此处 ⬆️⬆️
    // ...
});

```

### 可选配置 (顶部 `CONFIG` 对象)

* `ENABLE_COLOR`: 是否开启彩色日志（建议开启，除非你需要保存纯文本）。
* `STR_PEEK_LEN`: 内存透视读取的最大字符串长度（默认 32 字节）。
* `LOOP_THRESHOLD`: 同一行指令连续执行多少次后开始折叠日志。

---

## 🚀 如何运行

### 方式 1: 实时查看 (推荐 VS Code 终端)

建议使用支持 ANSI 颜色的终端（如 VS Code 内置终端、Windows Terminal）。

```bash
frida -U -f com.your.target.app -l trace_pro.js

```

* `-f`: 以 Spawn 模式启动 App（推荐，防止错过初始化时机）。
* `-l`: 加载脚本。

### 方式 2: 保存到文件 (推荐)

Trace 日志通常巨大，建议保存到文件分析。

```bash
frida -U -f com.your.target.app -l trace_pro.js -o trace.log

```

> **提示**: 生成的 `trace.log` 包含颜色代码。推荐使用 VS Code 安装 **"ANSI Colors"** 插件进行预览，或者在终端使用 `less -R trace.log` 查看。

---

## 🧐 这里的日志怎么看？

脚本输出的每一行代表一条汇编指令的执行。格式如下：

```text
[偏移]  地址        指令     操作数           ( 🕵️‍♂️ 详情与透视 )             | { 寄存器变化 }

```

### 示例解读

#### 1. 普通指令与内存透视

```text
[0x928] 0x77ad.. ldrb w11, [x10], #1  (w11=0x65, [x10]=0x77.. [val=0x65..] => "hello", #1)

```

* **`ldrb`**: 正在加载一个字节。
* **`w11=0x65`**: 加载到了 `0x65` (即字符 'e')。
* **`[val=0x65..] => "hello"`**: 脚本发现 `x10` 指向的地址里存的是字符串 "hello"，直接帮你显示出来了。

#### 2. SIMD 向量运算 (加密算法常见)

```text
[0x7c0] 0x77ad.. ldp q1, q0, [x9]     (q1=0xff..a0, q0=0x00..d0, [x9]=...)

```

* **`q1=0xff..`**: 成功通过 CModule 读取到了 128 位的向量寄存器值（通常是 Key 或 IV）。
* 如果你看到 `(No-CModule)`, 说明 CModule 编译失败，请检查环境。

#### 3. 函数调用

```text
[0x12a] 0x77ad.. bl 0x77ad2d6880      (Call sub_1234)

```

* **黄色高亮**: 提醒你这里发生了一个子函数调用，程序流发生了跳转。

#### 4. 寄存器变化 (行尾)

```text
... (详情)   |  { x0=0x1, x1=0x500 }

```

* **含义**: 执行完这条指令后，`x0` 变成了 `1`，`x1` 变成了 `0x500`。这对于追踪函数返回值非常有用。

---

